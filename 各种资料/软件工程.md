**某一系统全部完成需要6个月时间, 为了配合本年度的科技项目几种申请的预置时间, 要求2个月后系统就要上线, 请根据风险分析为该系统选择一个合适的开发模型, 设计定制初步的提交方案, 简要说明理由. 注意: 要用软件工程的知识**



根据这个情况描述，我建议采用敏捷开发模型，如Scrum或者XP，来开发这个系统。

理由如下：

首先: 时间紧迫，需要快速响应变化：由于项目需要在2个月内上线，时间非常紧张。传统的瀑布模型需要在每个阶段进行完整的规划、设计、开发和测试，耗费的时间较长，无法适应快速变化的需求。而敏捷开发模型强调迭代开发和快速响应变化，可以在短时间内交付部分功能，满足项目紧急上线的需求。敏捷开发比较适合那种有明显紧急的时间要求、项目本身复杂程度高且比较新颖、团队自主性强的项目。

风险较高，需要不断验证和改进：由于时间紧迫，可能存在一些风险和不确定性; 此外, 这个项目本身复杂度要高些且比较新颖, 所以开发项目的复杂度都很高。采用敏捷开发模型可以不断验证和改进方案，及时发现和解决问题，降低项目失败的风险。

最后，团队成员自主性要强。实施敏捷开发的基础就是要有一个高度自觉和自主性的团队，敏捷开发是以人为本的。

基于以上原因，我建议采用Scrum或XP开发模型，每个迭代时间可以设置为2周，每个迭代交付一个可用版本，同时每个迭代结束后进行回顾和反思，发现和解决问题，不断优化开发过程。

具体的提交方案可以按照敏捷开发模型的要求，采用产品积压清单(Product Backlog)来管理需求，每个迭代从积压清单中选取一些优先级较高的需求来开发，完成后进行测试、集成和交付。在迭代过程中，可以通过持续集成和自动化测试等技术手段，不断保证代码质量和可靠性，降低风险。
具体的提交方案可以按照以下步骤来设计：

1.明确需求：首先需要明确用户需求，并建立产品积压清单(Product Backlog)，将需求按照优先级排序。在短时间内，可以先梳理出较为紧急和关键的需求。

2.计划迭代周期和交付内容：针对上述优先级高的需求，将每个迭代周期设置为2周，并计划在每个迭代中完成某些具体的需求，并交付相应的可用版本。可以在每个迭代结束后，进行回顾和反思，不断优化迭代的计划和开发流程。

3.开发和测试：在每个迭代周期中，开发人员需要根据积压清单中的需求，完成相应的开发工作，并在完成后进行单元测试和集成测试。这里需要注意，代码的质量和可靠性是保证整个项目成功的关键，因此需要使用一些技术手段，例如持续集成和自动化测试等，来不断保证代码的质量和可靠性。

4.交付和验收：在每个迭代周期结束后，交付相应的可用版本，并邀请用户进行验收。如果用户反馈有问题，及时进行修复和改进。

5.不断迭代和优化：在整个开发过程中，需要不断进行迭代和优化，以达到最终的项目目标。在迭代结束后，可以进行回顾和反思，发现和解决问题，并不断优化开发流程。

总之，上述提交方案基于敏捷开发模型，将开发过程分解成多个短周期，可以快速响应需求变化，及时发现和解决问题，降低项目失败的风险。同时，通过不断迭代和优化，可以最终实现项目目标。



**首先是人员成本：**

试想你是一个程序猿，如果你工作在瀑布模型中，那么当需求人员在与客户沟通需求中，需求文档还没有出来，由于瀑布模型以文档驱动，此时你是处于空闲状态的，你后面的测试兄弟也是如此；而在敏捷模式中，每个开发测试人员都是全程参与每个迭代的，因此人员充分参与所有过程。

**其次是沟通成本：**

在传统的瀑布模型中，需求、开发、测试人员都在不同的Team中，假设开发要与需求沟通，那么要跨Team去沟通，时间和空间无法保证同步，因此沟通成本较高；而敏捷开发团队中的人员都在一个Scrum Team中，团队不大，沟通起来成本很小。

**最后是风险成本：**

对于瀑布模式，最大的风险成本来源于一旦开发过程中有需求变更或者严重的问题，所有流程都要回滚到上个阶段推倒重来，且越到后期风险越高，修改的成本越大；而对敏捷模式，可以很灵活轻松的面对需求变更，有任何bug、需求更改可以放到下一个迭代去做，大大降低了开发过程中的风险成本。



敏捷开发的十二条原则中有一条叫做：激发个体的斗志，以他们为核心搭建项目。

敏捷开发是一种以人为核心、迭代、循序渐进的开发方法，在敏捷开发过程中，人是第一位的，过程是第二位的，当然也对个人的能力和自主性提出了更高的要求



**在敏捷开发过程中，需要注意以下几点：**

1. 重视需求变化：敏捷开发强调快速响应变化，因此在整个开发过程中，需要重视需求变化，并及时进行调整。团队成员需要密切合作，不断沟通和协作，以确保开发方向和需求的一致性。
2. 确定优先级：由于时间和资源的限制，不能在短时间内完成所有的需求，因此需要确定优先级，将最重要、最关键的需求放在前面进行开发。在这个过程中，需要团队成员之间的协作和沟通，确保每个人都了解优先级的情况。
3. 着重质量控制：敏捷开发的迭代周期较短，开发人员需要在短时间内完成开发和测试工作。为了确保代码质量和可靠性，需要采用一些技术手段，如自动化测试和持续集成，以及严格的代码审查和质量控制流程。
4. 保持透明和沟通：敏捷开发要求团队成员之间保持高度的透明和沟通。在整个开发过程中，需要及时地向团队成员、项目负责人和用户反馈开发情况和进展，以及任何问题和风险。同时，需要促进团队成员之间的交流和协作，以实现整个开发团队的高效合作。
5. 持续改进：敏捷开发强调迭代和优化，因此需要在开发过程中不断进行回顾和反思，发现和解决问题，并改进开发过程。团队成员需要持续关注开发过程中的问题和挑战，并及时地进行改进和优化。



**MVC设计模式进行软件系统分析与设计时, 实体对象通常是被动的和持久性的,请对实体进行优化设计. 用语言画出MVC设计的原始类图, 并画出优化后的新类图.**

在MVC设计模式中，实体对象通常是被动的和持久性的，也就是说，它们主要用于表示应用程序中的数据，并提供对该数据的访问方法，而不处理业务逻辑或用户界面。因此，在对实体进行优化设计时，需要考虑如何提高它们的性能和效率。

通常，对实体进行优化设计的方法包括：

1. 缓存数据：将数据存储在内存中，以便更快地访问和处理数据。
2. 减少数据库操作：减少数据库访问次数可以大大提高性能。
3. 使用数据访问对象模式（Data Access Object，DAO）：将数据库操作封装在一个独立的对象中，以提高代码的可维护性和可重用性。

下面是MVC设计模式的原始类图和优化后的类图的示例，用文字描述类图，以便更好地理解：

原始类图：

```
+--------------+       +--------------+       +--------------+
|    Model     |       |    View      |       |  Controller  |
+--------------+       +--------------+       +--------------+
| - data       |       | - display()  |       | - update()   |
| - setData()  |<----->|              |<----->| - process()  |
| - getData()  |       |              |       |              |
+--------------+       +--------------+       +--------------+
```

在原始的MVC类图中，Model是实体对象，它存储和提供应用程序的数据。View是用户界面，它负责显示数据。Controller是应用程序的逻辑，它处理用户的输入并更新Model和View。

优化后的类图：

```
+----------------+       +-----------------+       +-------------------+
|      Model     |       |       View      |       |     Controller     |
+----------------+       +-----------------+       +-------------------+
| - cache        |       | - display()     |       | - update()        |
| - DAO          |<----->|                 |<----->| - process()       |
| - getData()    |       |                 |       | - getFromCache()  |
+----------------+       +-----------------+       | - updateCache()   |
                                                     +-------------------+
```

在优化后的MVC类图中，Model仍然是实体对象，但是它使用缓存来提高性能，并使用DAO模式将数据库操作封装在一个独立的对象中。View和Controller保持不变。

在MVC设计模式中，实体对象通常代表数据模型，是系统中的重要组成部分。为了提高系统的性能和可维护性，需要对实体进行优化设计。以下是一些常见的优化方法：

1. 使用缓存：对于需要频繁读取的实体数据，可以使用缓存来减少对数据库的访问，提高系统性能。
2. 分区表：对于数据量较大的实体，可以使用分区表来将数据分散到多个表中，提高查询速度和扩展性。
3. 惰性加载：对于关联实体，可以采用惰性加载的方式，即在需要访问相关实体数据时才进行加载，避免不必要的数据加载和内存占用。
4. 使用索引：对于经常查询的实体属性，可以使用索引来提高查询速度。
5. 减少关联：对于实体之间的关联，需要根据实际情况进行优化，避免不必要的关联，减少数据库访问次数。
6. 数据库设计：在进行实体优化设计时，需要考虑数据库设计的优化，如适当地分解表、使用合适的数据类型等。

总的来说，实体的优化设计是一个综合性的工作，需要综合考虑系统的需求、数据模型的复杂度、数据量、查询频率等多方面因素。

**ppt第七章**





(一) 根据伪代码画出程序流程图

```csharp
public void foo (int a, int b, int x) {
    if(a>1 && b ==0) {
        x = x/a;
    }

    if (a==2 || x>1) {
        x = x+1;
    }
}
```

![](https://upload-images.jianshu.io/upload_images/8916670-1bb51a55365aa797.png?imageMogr2/auto-orient/strip|imageView2/2/w/211/format/webp)



![](https://img-blog.csdnimg.cn/2be754150e65495d839533395281b3c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN5YGa55-b55u-5L2T,size_20,color_FFFFFF,t_70,g_se,x_16)

<img src="https://img-blog.csdnimg.cn/221bfa2d76aa4a0b957280d11428145c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LiN5YGa55-b55u-5L2T,size_19,color_FFFFFF,t_70,g_se,x_16" style="zoom:67%;" />

```
C	EXAMPLE
LOOP:DO WHILE Z>0
	A=B+1
	IF A>10
		THEN X=A
		ELSE Y=Z
	END IF
	IF Y<5
		THEN PRINT X,Y
		ELSE IF Y=2
			THEN GOTO LOOP
			ELSE C=3
			END IF
	END IF
	G=H+R
	END DO
	IF F>0
		THEN PRINT G
		ELSE PRINT K
	END IF
	STOP
```

![](https://img-blog.csdnimg.cn/20210530132213324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NzIxOTg3NQ==,size_16,color_FFFFFF,t_70)



总结:

1. 顺序执行流程图
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201130224645624.png)
2. 条件判断流程图
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201130225127899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9iYW5nc2t5,size_16,color_FFFFFF,t_70)
3. 循环流程图
   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201130225302269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9iYW5nc2t5,size_16,color_FFFFFF,t_70)
   <img src="https://img-blog.csdnimg.cn/20201130225319773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9iYW5nc2t5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:150%;" />
   <img src="https://img-blog.csdnimg.cn/20201130225329540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9iYW5nc2t5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:150%;" />



**语句覆盖**：每条语句至少执行一次。

**判定覆盖**：每个判定的所有可能结果至少出现一次。（又称“分支覆盖”）

**条件覆盖**：每个条件的所有可能结果至少执行一次。

**判定/条件覆盖**：一个判定中的每个条件的所有可能结果至少执行一次，并且每个判断本身的所有可能结果至少执行一次。

**多重条件覆盖**（组合覆盖）：每个判定中的所有可能的条件结果的组合，以及所有的入口点都至少执行一次。（注意“可能”二字，因为有些组合的情况难以生成。）

**完全路径覆盖**：每条路径至少执行一次。

覆盖程度: 路径覆盖 > 多重条件覆盖 > 判定/条件覆盖 > 条件覆盖 > 判定覆盖 > 语句覆盖

![img](https://pic-1259640338.cos.ap-shanghai.myqcloud.com/img/Screen%20Shot%202021-06-12%20at%2000.42.35.png)

![img](https://pic-1259640338.cos.ap-shanghai.myqcloud.com/img/Screen%20Shot%202021-06-12%20at%2000.43.03.png)

![image-20230226121738288](C:/Users/29185/AppData/Roaming/Typora/typora-user-images/image-20230226121738288.png)

![image-20230226121748461](C:/Users/29185/AppData/Roaming/Typora/typora-user-images/image-20230226121748461.png)

![image-20230226121758820](C:/Users/29185/AppData/Roaming/Typora/typora-user-images/image-20230226121758820.png)

![image-20230226121819441](C:/Users/29185/AppData/Roaming/Typora/typora-user-images/image-20230226121819441.png)